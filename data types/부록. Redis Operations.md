# 레디스 아키텍처

## 이벤트 루프 싱글 스레드

레디스에서 명령어를 처리하는 부분은 싱글 스레드로 동작하여 원자성을 보장한다. 레디스 6.0 부터 I/O가 발생하는 부분은 멀티 스레딩이 적용됐다.

## 왜 싱글 스레드일까?

레디스는 왜 싱글 스레드로 설계를 하였을까? 그 이유는 멀티 스레드로 설계 시 잠금과 동기화로 인한 코드 복잡성 증가와 이로인한 성능 저하가 발생할 수 있고 이를 구현하지 않았을 경우 동시성 문제가 발생하기 쉽기 때문이다.

레디스는 epoll I/O 멀티플렉싱을 사용하여 싱글 스레드로도 빠른 처리가 가능하도록 설계되어 있다.

I/O 멀티플렉싱(I/O Multiplexing)은 하나의 스레드 또는 프로세스가 여러 개의 입출력(I/O) 스트림(파일 디스크립터, 소켓 등)을 동시에 감시하고, 특정 이벤트(데이터 수신, 연결 가능 등)가 발생했을 때만 해당 스트림을 처리하는 기술입니다.

## 레디스 요청/응답 프로세스

aeMain(ae.c 474) → aeProcessEvents(ae.c 342) → beforeSleep(server.c 1656) → handlerClientsWithPendingReadsUsingThreads(networking.c 4582) → processPendingCommandAndInputBuffer(networking.c 2565) → processCommandAndResetClient(networking.c 253)  → processCommand(server.c 3903) → handlerClientsWithPendingWritesUsingThreads (networking.c 4457)


![redis architecture](https://github.com/user-attachments/assets/44d9f494-6b3b-43d6-a37f-8a65a177a1e6)

# 레디스 운용

## 캐시 서버 레디스 아키텍처

### 읽기 관점 아키텍처

읽기 관점 아키텍처에는 원본 데이터는 RDBMS에 저장하고 레디스는 그 앞단에 배치하는 형태이며, 두 가지 패턴이 존재한다.

- Look-Aside 패턴
	- Lazy Loding 패턴 또는 Cache-Aside 패턴이라고도 불림
	- 캐시 관리 주체가 애플리케이션
	- 요청 처리 흐름
		1. 애플리케이션은 요청을 받아 레디스에 데이터가 존재하는 지 확인
		2. 데이터가 레디스에 존재하고 유효 기간 내에 있는 경우라면 캐싱된 데이터를 애플리케이션에게 응답하고 애플리케이션은 이 데이터를 클라이언트에게 응답
		3. 데이터가 레디스에 존재하지 않거나 유효 기간이 지난 경우라면 애플리케이션은 RDBMS에서 데이터를 가져온 후 해당 데이터를 레디스에 업데이트하고 클라이언트에게 응답
	- 장점
		- 요청된 데이터만 캐시에 저장하므로, 캐시로 사용되는 공간이 작을 수 있음
		- 레디스에 장애 발생 시 RDBMS를 통한 조회가 가능하기 때문에 서비스의 전체적인 장애로 이어지지 않음
	- 단점
		- TTL을 사용하지 않으면 캐시된 데이터는 오래된 데이터일 가능성이 높음
		- 캐시미스 발생 시 RDBMS에 질의를 해야하기 때문에 성능저하 발생
		- 레디스에 장애 발생 시 RDBMS에 DB 부하 발생
![look-aside](https://github.com/user-attachments/assets/f8be9d42-0f6e-4188-b05d-cedbacaee6e2)
- Read-Through 패턴
	- 캐시미스 발생 시 애플리케이션에서 RDBMS에 데이터를 직접 조회하는 것이 아닌 라이브러리 등을 사용해 레디스에서 직접 읽는 방식
	- 캐시 관리 주체가 레디스
	- 장점
		- 애플리케이션에서 RDBMS를 통한 조회 코드가 필요 없음
	- 단점
		- 레디스에 장애 발생 시 서비스의 전제적인 장애로 이어짐
		- 레디스에서 RDBMS로 접근하는 부분은 레디스의 내장 기능으로 제공되지 않으므로 외부 라이브러리를 사용해야 함
![read-through](https://github.com/user-attachments/assets/dba4ebce-ea57-4a3f-b9c8-312fccdc4939)

### 쓰기 관점 아키텍처

- Write-Through 패턴
	- 애플리케이션에서 RDBMS에 쓰기 작업을 완료한 후에 레디스에 동기화하는 방식
	- 쓰기 작업 때 지연 시간이 다소 증가해도 괜찮은 서비스에 적합
	- 레디스로 동기화하는 주체가 애플리케이션
	- 장점
		- 레디스내의 캐시 데이터가 항상 최신 상태를 유지
		- 읽기 작업 시 오버헤드가 적음
	- 단점
		- 사용하지 않는 캐시 데이터가 레디스에 동기화될 가능성이 있음
		- RDBMS, 레디스에 쓰기 작업을 해야 하므로 오버헤드가 큼
![write-through](https://github.com/user-attachments/assets/9cfd0223-5bc9-4407-9d70-1d32ea544dfa)
- Write-Back 패턴
	- 레디스에 저장 후 일정 시간 마다 비동기 방식으로 RDBMS에 동기화하는 방식
	- 데이터 손실이 발생해도 큰 문제가 없고 성능이 우선시 되는 서비스에 적합
	- 장점
		- 레디스내의 캐시 데이터가 항상 최신 상태를 유지
		- 쓰기, 읽기 작업을 빨리 처리할 수 있음
		- 많은 쓰기 요청 발생 시 RDBMS가 받는 부하를 줄일 수 있음
	- 단점
		- 레디스에 장애 발생 시 RDBMS에 데이터의 동기화가 이루어지지 않을 수 있음
![write-back](https://github.com/user-attachments/assets/382a31e7-aa2c-4d5f-b473-02e9207c006b)
- Write-Around 패턴
	- 애플리케이션에서 RDBMS에 쓰기 작업을 완료한 후에 CDC 방식을 사용하여 레디스에 동기화하는 방식
	- 레디스로 동기화하는 주체가 RDBMS 또는 레디스
	- 장점
		- 레디스내의 캐시 데이터가 항상 최신 상태를 유지
	- 단점
		- 구현 방법이 까다로움

## TTL

지정된 시간 동안만 데이터를 저장하는 기능을 말한다. TTL이 만료된 키를 삭제하는 방식은 다음과 같다.

- passive way
	- 만료된 키는 메모리에서 바로 삭제되지 않음
	- 만료된 키에 대해서 접근하려고 시도하는 순간 만료 여부를 확인하고 만료된 경우 해당 키를 메모리에서 삭제
- active way
	- secondary hash table을 샘플링하여 만료된 키들을 삭제
	- 여기서 말하는 샘플링이란 무작위로 키를 선택해서 만료 여부를 확인하는 방식
	- 만료 키 삭제 방식
		1. secondary hash table을 샘플링하여 만료 여부를 확인하고 만료된 키는 즉시 삭제
		2. 만료될 가능성이 있는 키는 Radix Tree에 저장
		3. 이후 active expiration 실행 시 Radix Tree를 먼저 탐색하여 만료된 키를 삭제
		4. 1번 부터 다시 반복
- https://redis.io/kb/doc/1fqjridk8w/what-are-the-impacts-of-the-redis-expiration-algorithm

# 주의 사항

## 키 삭제 명령어 DEL vs UNLINK

|  | DEL | UNLINK |
| --- | --- | --- |
| 시간 복잡도 | O(N) | O(1) |
| 동작 방식 | 즉시 동기적으로 삭제 | 백그라운드에서 비동기적으로 삭제(Lazy Freeing) |
| 키 패턴 | 사용 불가능 | 사용 불가능 |
| 성능 | 즉시 실행되므로 전체 처리 시간이 느려질 수 있음 | 비동기적으로 실행되기 때문에 전체 성능에 미치는 영향이 적음 |
| 사용 예시 | 키에 저장된 요소의 개수가 적은 키를 삭제할 때 적합 | 운영 환경에서 키에 저장된 요소의 개수가 많은 키를 삭제할 때 적합 |

기본적으로 레디스는 단일 스레드 구조이기 때문에 DEL 명령어로 많은 키를 삭제가 진행 중인 경우에 추가적으로 많은 요청이 들어오게 되면 네트워크 I/O가 증가, 요청을 작업 큐에 저장 및 처리 준비 작업으로인해 CPU 부하가 급증할 수 있다.

## 키 검색 명령어 KEYS vs SCAN

|  | KEYS | SCAN |
| --- | --- | --- |
| 시간 복잡도 | O(N) | O(1) |
| 동작 방식 | 동기적으로 모든 키를 검색하여 한 번에 반환 | 동기적으로 커서를 사용하여 지정한 개수 만큼의 키를 반환 |
| 키 패턴 | 사용가능 | 사용가능 |
| 성능 | 모든 키를 검색하므로 처리 시간이 느리며, 메모리 사용량이 높음 | 작은 개수의 키를 처리할 수 있기 때문에 처리 시간이 빠르고 메모리 사용량이 적음 |
| 사용 예시 | 키의 개수가 적은 경우 | 키의 개수가 많은 경우 |

참고: https://tech.kakao.com/posts/314